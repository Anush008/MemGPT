import asyncio
from fastapi import FastAPI
from asyncio import AbstractEventLoop
from enum import Enum
import json
import uuid
from typing import List, Optional

from fastapi import APIRouter, Depends, Body, HTTPException, Query, Path
from pydantic import BaseModel, Field, constr, validator
from starlette.responses import StreamingResponse

from memgpt.server.rest_api.interface import QueuingInterface
from memgpt.server.server import SyncServer

from memgpt.server.server import SyncServer
from memgpt.server.rest_api.interface import QueuingInterface
from memgpt.server.rest_api.static_files import mount_static_files
from memgpt.models.openai.messages import Message

"""
Basic REST API sitting on top of the internal MemGPT python server (SyncServer)

Start the server with:
  cd memgpt/server/rest_api
  poetry run uvicorn server:app --reload
"""

interface: QueuingInterface = QueuingInterface()
server: SyncServer = SyncServer(default_interface=interface)


router = APIRouter()
app = FastAPI()


class MessageRoleType(str, Enum):
    user = "user"
    system = "system"


class UserMessageRequest(BaseModel):
    user_id: str = Field(..., description="The unique identifier of the user.")
    agent_id: str = Field(..., description="The unique identifier of the agent.")
    message: str = Field(..., description="The message content to be processed by the agent.")
    stream: bool = Field(default=False, description="Flag to determine if the response should be streamed. Set to True for streaming.")
    role: MessageRoleType = Field(default=MessageRoleType.user, description="Role of the message sender (either 'user' or 'system')")


class UserMessageResponse(BaseModel):
    messages: List[dict] = Field(..., description="List of messages generated by the agent in response to the received message.")


class GetAgentMessagesRequest(BaseModel):
    user_id: str = Field(..., description="The unique identifier of the user.")
    agent_id: str = Field(..., description="The unique identifier of the agent.")
    start: int = Field(..., description="Message index to start on (reverse chronological).")
    count: int = Field(..., description="How many messages to retrieve.")


class ListMessagesResponse(BaseModel):
    messages: list = Field(..., description="List of message objects.")


@router.post("/v1/threads/{thread_id}/messages", tags=["assistants"], response_model=Message)
def create_message(
    thread_id: str = Path(..., description="The unique identifier of the thread."),
    role: MessageRoleType = Query(..., description="Role of the message sender (either 'user' or 'system')"),
    content: str = Query(..., description="The message content to be processed by the agent."),
    file_ids: Optional[List[str]] = Query(..., description="List of file IDs associated with the message."),
    metadata: Optional[dict] = Query(..., description="Metadata associated with the message."),
    user_id: str = Query(..., description="The unique identifier of the user."),  # TODO: remove
):
    user_id = uuid.UUID(user_id)
    agent_id = uuid.UUID(thread_id)
    # TODO: need to add a buffer/queue to server and pull on .step()


@router.get("/v1/threads/{thread_id}/messages", tags=["assistants"], response_model=ListMessagesResponse)
def list_messages(
    thread_id: str = Path(..., description="The unique identifier of the thread."),
    limit: int = Query(..., description="How many messages to retrieve."),
    order: str = Query(..., description="Order of messages to retrieve (either 'asc' or 'desc')."),
    after: str = Query(..., description="A cursor for use in pagination. `after` is an object ID that defines your place in the list."),
    before: str = Query(..., description="A cursor for use in pagination. `after` is an object ID that defines your place in the list."),
    user_id: str = Query(..., description="The unique identifier of the user."),  # TODO: remove
):
    after_uuid = uuid.UUID(after) if before else None
    before_uuid = uuid.UUID(before) if before else None
    user_id = uuid.UUID(user_id)
    agent_id = uuid.UUID(thread_id)
    reverse = True if (order == "desc") else False
    messages = server.get_agent_recall_cursor(
        user_id=user_id,
        agent_id=agent_id,
        limit=limit,
        order=order,
        after=after_uuid,
        before=before_uuid,
        order_by="created_at",
        reverse=reverse,
    )
    # TODO: cast back to message objects
    return ListMessagesResponse(messages=messages)
